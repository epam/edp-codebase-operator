// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	v2 "github.com/epam/edp-codebase-operator/v2/pkg/git/v2"
	mock "github.com/stretchr/testify/mock"
)

// MockGit is an autogenerated mock type for the Git type
type MockGit struct {
	mock.Mock
}

type MockGit_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGit) EXPECT() *MockGit_Expecter {
	return &MockGit_Expecter{mock: &_m.Mock}
}

// AddRemoteLink provides a mock function with given fields: ctx, directory, remoteURL
func (_m *MockGit) AddRemoteLink(ctx context.Context, directory string, remoteURL string) error {
	ret := _m.Called(ctx, directory, remoteURL)

	if len(ret) == 0 {
		panic("no return value specified for AddRemoteLink")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, directory, remoteURL)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_AddRemoteLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRemoteLink'
type MockGit_AddRemoteLink_Call struct {
	*mock.Call
}

// AddRemoteLink is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - remoteURL string
func (_e *MockGit_Expecter) AddRemoteLink(ctx interface{}, directory interface{}, remoteURL interface{}) *MockGit_AddRemoteLink_Call {
	return &MockGit_AddRemoteLink_Call{Call: _e.mock.On("AddRemoteLink", ctx, directory, remoteURL)}
}

func (_c *MockGit_AddRemoteLink_Call) Run(run func(ctx context.Context, directory string, remoteURL string)) *MockGit_AddRemoteLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockGit_AddRemoteLink_Call) Return(_a0 error) *MockGit_AddRemoteLink_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_AddRemoteLink_Call) RunAndReturn(run func(context.Context, string, string) error) *MockGit_AddRemoteLink_Call {
	_c.Call.Return(run)
	return _c
}

// CheckPermissions provides a mock function with given fields: ctx, repoURL
func (_m *MockGit) CheckPermissions(ctx context.Context, repoURL string) error {
	ret := _m.Called(ctx, repoURL)

	if len(ret) == 0 {
		panic("no return value specified for CheckPermissions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, repoURL)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_CheckPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPermissions'
type MockGit_CheckPermissions_Call struct {
	*mock.Call
}

// CheckPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - repoURL string
func (_e *MockGit_Expecter) CheckPermissions(ctx interface{}, repoURL interface{}) *MockGit_CheckPermissions_Call {
	return &MockGit_CheckPermissions_Call{Call: _e.mock.On("CheckPermissions", ctx, repoURL)}
}

func (_c *MockGit_CheckPermissions_Call) Run(run func(ctx context.Context, repoURL string)) *MockGit_CheckPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGit_CheckPermissions_Call) Return(_a0 error) *MockGit_CheckPermissions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_CheckPermissions_Call) RunAndReturn(run func(context.Context, string) error) *MockGit_CheckPermissions_Call {
	_c.Call.Return(run)
	return _c
}

// CheckReference provides a mock function with given fields: ctx, directory, refName
func (_m *MockGit) CheckReference(ctx context.Context, directory string, refName string) error {
	ret := _m.Called(ctx, directory, refName)

	if len(ret) == 0 {
		panic("no return value specified for CheckReference")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, directory, refName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_CheckReference_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckReference'
type MockGit_CheckReference_Call struct {
	*mock.Call
}

// CheckReference is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - refName string
func (_e *MockGit_Expecter) CheckReference(ctx interface{}, directory interface{}, refName interface{}) *MockGit_CheckReference_Call {
	return &MockGit_CheckReference_Call{Call: _e.mock.On("CheckReference", ctx, directory, refName)}
}

func (_c *MockGit_CheckReference_Call) Run(run func(ctx context.Context, directory string, refName string)) *MockGit_CheckReference_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockGit_CheckReference_Call) Return(_a0 error) *MockGit_CheckReference_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_CheckReference_Call) RunAndReturn(run func(context.Context, string, string) error) *MockGit_CheckReference_Call {
	_c.Call.Return(run)
	return _c
}

// Checkout provides a mock function with given fields: ctx, directory, branchName, remote
func (_m *MockGit) Checkout(ctx context.Context, directory string, branchName string, remote bool) error {
	ret := _m.Called(ctx, directory, branchName, remote)

	if len(ret) == 0 {
		panic("no return value specified for Checkout")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) error); ok {
		r0 = rf(ctx, directory, branchName, remote)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Checkout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Checkout'
type MockGit_Checkout_Call struct {
	*mock.Call
}

// Checkout is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - branchName string
//   - remote bool
func (_e *MockGit_Expecter) Checkout(ctx interface{}, directory interface{}, branchName interface{}, remote interface{}) *MockGit_Checkout_Call {
	return &MockGit_Checkout_Call{Call: _e.mock.On("Checkout", ctx, directory, branchName, remote)}
}

func (_c *MockGit_Checkout_Call) Run(run func(ctx context.Context, directory string, branchName string, remote bool)) *MockGit_Checkout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockGit_Checkout_Call) Return(_a0 error) *MockGit_Checkout_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Checkout_Call) RunAndReturn(run func(context.Context, string, string, bool) error) *MockGit_Checkout_Call {
	_c.Call.Return(run)
	return _c
}

// CheckoutRemoteBranch provides a mock function with given fields: ctx, directory, branchName
func (_m *MockGit) CheckoutRemoteBranch(ctx context.Context, directory string, branchName string) error {
	ret := _m.Called(ctx, directory, branchName)

	if len(ret) == 0 {
		panic("no return value specified for CheckoutRemoteBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, directory, branchName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_CheckoutRemoteBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckoutRemoteBranch'
type MockGit_CheckoutRemoteBranch_Call struct {
	*mock.Call
}

// CheckoutRemoteBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - branchName string
func (_e *MockGit_Expecter) CheckoutRemoteBranch(ctx interface{}, directory interface{}, branchName interface{}) *MockGit_CheckoutRemoteBranch_Call {
	return &MockGit_CheckoutRemoteBranch_Call{Call: _e.mock.On("CheckoutRemoteBranch", ctx, directory, branchName)}
}

func (_c *MockGit_CheckoutRemoteBranch_Call) Run(run func(ctx context.Context, directory string, branchName string)) *MockGit_CheckoutRemoteBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockGit_CheckoutRemoteBranch_Call) Return(_a0 error) *MockGit_CheckoutRemoteBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_CheckoutRemoteBranch_Call) RunAndReturn(run func(context.Context, string, string) error) *MockGit_CheckoutRemoteBranch_Call {
	_c.Call.Return(run)
	return _c
}

// Clone provides a mock function with given fields: ctx, repoURL, destination
func (_m *MockGit) Clone(ctx context.Context, repoURL string, destination string) error {
	ret := _m.Called(ctx, repoURL, destination)

	if len(ret) == 0 {
		panic("no return value specified for Clone")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, repoURL, destination)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Clone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clone'
type MockGit_Clone_Call struct {
	*mock.Call
}

// Clone is a helper method to define mock.On call
//   - ctx context.Context
//   - repoURL string
//   - destination string
func (_e *MockGit_Expecter) Clone(ctx interface{}, repoURL interface{}, destination interface{}) *MockGit_Clone_Call {
	return &MockGit_Clone_Call{Call: _e.mock.On("Clone", ctx, repoURL, destination)}
}

func (_c *MockGit_Clone_Call) Run(run func(ctx context.Context, repoURL string, destination string)) *MockGit_Clone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockGit_Clone_Call) Return(_a0 error) *MockGit_Clone_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Clone_Call) RunAndReturn(run func(context.Context, string, string) error) *MockGit_Clone_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields: ctx, directory, message, ops
func (_m *MockGit) Commit(ctx context.Context, directory string, message string, ops ...v2.CommitOps) error {
	_va := make([]interface{}, len(ops))
	for _i := range ops {
		_va[_i] = ops[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, directory, message)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...v2.CommitOps) error); ok {
		r0 = rf(ctx, directory, message, ops...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type MockGit_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - message string
//   - ops ...v2.CommitOps
func (_e *MockGit_Expecter) Commit(ctx interface{}, directory interface{}, message interface{}, ops ...interface{}) *MockGit_Commit_Call {
	return &MockGit_Commit_Call{Call: _e.mock.On("Commit",
		append([]interface{}{ctx, directory, message}, ops...)...)}
}

func (_c *MockGit_Commit_Call) Run(run func(ctx context.Context, directory string, message string, ops ...v2.CommitOps)) *MockGit_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]v2.CommitOps, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(v2.CommitOps)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Commit_Call) Return(_a0 error) *MockGit_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Commit_Call) RunAndReturn(run func(context.Context, string, string, ...v2.CommitOps) error) *MockGit_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// CommitExists provides a mock function with given fields: ctx, directory, hash
func (_m *MockGit) CommitExists(ctx context.Context, directory string, hash string) (bool, error) {
	ret := _m.Called(ctx, directory, hash)

	if len(ret) == 0 {
		panic("no return value specified for CommitExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, directory, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, directory, hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, directory, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_CommitExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitExists'
type MockGit_CommitExists_Call struct {
	*mock.Call
}

// CommitExists is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - hash string
func (_e *MockGit_Expecter) CommitExists(ctx interface{}, directory interface{}, hash interface{}) *MockGit_CommitExists_Call {
	return &MockGit_CommitExists_Call{Call: _e.mock.On("CommitExists", ctx, directory, hash)}
}

func (_c *MockGit_CommitExists_Call) Run(run func(ctx context.Context, directory string, hash string)) *MockGit_CommitExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockGit_CommitExists_Call) Return(_a0 bool, _a1 error) *MockGit_CommitExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_CommitExists_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockGit_CommitExists_Call {
	_c.Call.Return(run)
	return _c
}

// CreateChildBranch provides a mock function with given fields: ctx, directory, parentBranch, newBranch
func (_m *MockGit) CreateChildBranch(ctx context.Context, directory string, parentBranch string, newBranch string) error {
	ret := _m.Called(ctx, directory, parentBranch, newBranch)

	if len(ret) == 0 {
		panic("no return value specified for CreateChildBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, directory, parentBranch, newBranch)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_CreateChildBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateChildBranch'
type MockGit_CreateChildBranch_Call struct {
	*mock.Call
}

// CreateChildBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - parentBranch string
//   - newBranch string
func (_e *MockGit_Expecter) CreateChildBranch(ctx interface{}, directory interface{}, parentBranch interface{}, newBranch interface{}) *MockGit_CreateChildBranch_Call {
	return &MockGit_CreateChildBranch_Call{Call: _e.mock.On("CreateChildBranch", ctx, directory, parentBranch, newBranch)}
}

func (_c *MockGit_CreateChildBranch_Call) Run(run func(ctx context.Context, directory string, parentBranch string, newBranch string)) *MockGit_CreateChildBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockGit_CreateChildBranch_Call) Return(_a0 error) *MockGit_CreateChildBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_CreateChildBranch_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockGit_CreateChildBranch_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRemoteBranch provides a mock function with given fields: ctx, directory, branchName, fromRef
func (_m *MockGit) CreateRemoteBranch(ctx context.Context, directory string, branchName string, fromRef string) error {
	ret := _m.Called(ctx, directory, branchName, fromRef)

	if len(ret) == 0 {
		panic("no return value specified for CreateRemoteBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, directory, branchName, fromRef)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_CreateRemoteBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRemoteBranch'
type MockGit_CreateRemoteBranch_Call struct {
	*mock.Call
}

// CreateRemoteBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - branchName string
//   - fromRef string
func (_e *MockGit_Expecter) CreateRemoteBranch(ctx interface{}, directory interface{}, branchName interface{}, fromRef interface{}) *MockGit_CreateRemoteBranch_Call {
	return &MockGit_CreateRemoteBranch_Call{Call: _e.mock.On("CreateRemoteBranch", ctx, directory, branchName, fromRef)}
}

func (_c *MockGit_CreateRemoteBranch_Call) Run(run func(ctx context.Context, directory string, branchName string, fromRef string)) *MockGit_CreateRemoteBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockGit_CreateRemoteBranch_Call) Return(_a0 error) *MockGit_CreateRemoteBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_CreateRemoteBranch_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockGit_CreateRemoteBranch_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRemoteTag provides a mock function with given fields: ctx, directory, branchName, tagName
func (_m *MockGit) CreateRemoteTag(ctx context.Context, directory string, branchName string, tagName string) error {
	ret := _m.Called(ctx, directory, branchName, tagName)

	if len(ret) == 0 {
		panic("no return value specified for CreateRemoteTag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, directory, branchName, tagName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_CreateRemoteTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRemoteTag'
type MockGit_CreateRemoteTag_Call struct {
	*mock.Call
}

// CreateRemoteTag is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - branchName string
//   - tagName string
func (_e *MockGit_Expecter) CreateRemoteTag(ctx interface{}, directory interface{}, branchName interface{}, tagName interface{}) *MockGit_CreateRemoteTag_Call {
	return &MockGit_CreateRemoteTag_Call{Call: _e.mock.On("CreateRemoteTag", ctx, directory, branchName, tagName)}
}

func (_c *MockGit_CreateRemoteTag_Call) Run(run func(ctx context.Context, directory string, branchName string, tagName string)) *MockGit_CreateRemoteTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockGit_CreateRemoteTag_Call) Return(_a0 error) *MockGit_CreateRemoteTag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_CreateRemoteTag_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockGit_CreateRemoteTag_Call {
	_c.Call.Return(run)
	return _c
}

// Fetch provides a mock function with given fields: ctx, directory, branchName
func (_m *MockGit) Fetch(ctx context.Context, directory string, branchName string) error {
	ret := _m.Called(ctx, directory, branchName)

	if len(ret) == 0 {
		panic("no return value specified for Fetch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, directory, branchName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Fetch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fetch'
type MockGit_Fetch_Call struct {
	*mock.Call
}

// Fetch is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - branchName string
func (_e *MockGit_Expecter) Fetch(ctx interface{}, directory interface{}, branchName interface{}) *MockGit_Fetch_Call {
	return &MockGit_Fetch_Call{Call: _e.mock.On("Fetch", ctx, directory, branchName)}
}

func (_c *MockGit_Fetch_Call) Run(run func(ctx context.Context, directory string, branchName string)) *MockGit_Fetch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockGit_Fetch_Call) Return(_a0 error) *MockGit_Fetch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Fetch_Call) RunAndReturn(run func(context.Context, string, string) error) *MockGit_Fetch_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentBranchName provides a mock function with given fields: ctx, directory
func (_m *MockGit) GetCurrentBranchName(ctx context.Context, directory string) (string, error) {
	ret := _m.Called(ctx, directory)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentBranchName")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, directory)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, directory)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, directory)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGit_GetCurrentBranchName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentBranchName'
type MockGit_GetCurrentBranchName_Call struct {
	*mock.Call
}

// GetCurrentBranchName is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
func (_e *MockGit_Expecter) GetCurrentBranchName(ctx interface{}, directory interface{}) *MockGit_GetCurrentBranchName_Call {
	return &MockGit_GetCurrentBranchName_Call{Call: _e.mock.On("GetCurrentBranchName", ctx, directory)}
}

func (_c *MockGit_GetCurrentBranchName_Call) Run(run func(ctx context.Context, directory string)) *MockGit_GetCurrentBranchName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGit_GetCurrentBranchName_Call) Return(_a0 string, _a1 error) *MockGit_GetCurrentBranchName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGit_GetCurrentBranchName_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockGit_GetCurrentBranchName_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function with given fields: ctx, directory
func (_m *MockGit) Init(ctx context.Context, directory string) error {
	ret := _m.Called(ctx, directory)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, directory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type MockGit_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
func (_e *MockGit_Expecter) Init(ctx interface{}, directory interface{}) *MockGit_Init_Call {
	return &MockGit_Init_Call{Call: _e.mock.On("Init", ctx, directory)}
}

func (_c *MockGit_Init_Call) Run(run func(ctx context.Context, directory string)) *MockGit_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGit_Init_Call) Return(_a0 error) *MockGit_Init_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Init_Call) RunAndReturn(run func(context.Context, string) error) *MockGit_Init_Call {
	_c.Call.Return(run)
	return _c
}

// Push provides a mock function with given fields: ctx, directory, refspecs
func (_m *MockGit) Push(ctx context.Context, directory string, refspecs ...string) error {
	_va := make([]interface{}, len(refspecs))
	for _i := range refspecs {
		_va[_i] = refspecs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, directory)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Push")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) error); ok {
		r0 = rf(ctx, directory, refspecs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_Push_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Push'
type MockGit_Push_Call struct {
	*mock.Call
}

// Push is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - refspecs ...string
func (_e *MockGit_Expecter) Push(ctx interface{}, directory interface{}, refspecs ...interface{}) *MockGit_Push_Call {
	return &MockGit_Push_Call{Call: _e.mock.On("Push",
		append([]interface{}{ctx, directory}, refspecs...)...)}
}

func (_c *MockGit_Push_Call) Run(run func(ctx context.Context, directory string, refspecs ...string)) *MockGit_Push_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGit_Push_Call) Return(_a0 error) *MockGit_Push_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_Push_Call) RunAndReturn(run func(context.Context, string, ...string) error) *MockGit_Push_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveBranch provides a mock function with given fields: ctx, directory, branchName
func (_m *MockGit) RemoveBranch(ctx context.Context, directory string, branchName string) error {
	ret := _m.Called(ctx, directory, branchName)

	if len(ret) == 0 {
		panic("no return value specified for RemoveBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, directory, branchName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGit_RemoveBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveBranch'
type MockGit_RemoveBranch_Call struct {
	*mock.Call
}

// RemoveBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - directory string
//   - branchName string
func (_e *MockGit_Expecter) RemoveBranch(ctx interface{}, directory interface{}, branchName interface{}) *MockGit_RemoveBranch_Call {
	return &MockGit_RemoveBranch_Call{Call: _e.mock.On("RemoveBranch", ctx, directory, branchName)}
}

func (_c *MockGit_RemoveBranch_Call) Run(run func(ctx context.Context, directory string, branchName string)) *MockGit_RemoveBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockGit_RemoveBranch_Call) Return(_a0 error) *MockGit_RemoveBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGit_RemoveBranch_Call) RunAndReturn(run func(context.Context, string, string) error) *MockGit_RemoveBranch_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGit creates a new instance of MockGit. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGit(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGit {
	mock := &MockGit{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
